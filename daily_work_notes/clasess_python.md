We discussed whether we needed a class specifically for collision handling, as we found ourselves picking and choosing from its methods. Normally, objects meld member variables with behaviors. Yet, our class wasn't a clear-cut blueprint for a structured process; rather, it was a compilation of small, topic-focused methods. Further research led us to see the value in such a class due to its focused role, enhancing code organization. The initial worry was that this class, being a mix of loosely connected methods, might lack cohesion, making it harder to maintain or understand. However, centralizing similar functions in one class simplifies updates, debugging, and code reuseâ€”key for sustainable software development. Despite not fitting the classic object-oriented model of blending member variables and behaviors to mirror real-world entities, this class as a specialized tool for collision tasks holds considerable advantages. It simplifies the complexity around detecting collisions. Ultimately, recognizing the class's worth reflects a practical take on software design, marrying object-oriented principles with the real demands of the software's structure.